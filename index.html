<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Plinko with Effects</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
  <style>
    /* Global Styles with a Modern Feel */
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background: #e0e0e0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      flex-direction: column;
    }
    
    #gameContainer {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      padding: 20px;
      width: 520px;
    }
    
    h1 {
      color: #333;
      margin-bottom: 10px;
    }
    
    #controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    #controls span {
      font-size: 18px;
      color: #333;
    }
    
    #controls label {
      font-size: 16px;
      color: #555;
      margin-right: 5px;
    }
    
    #priceInput {
      width: 70px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 16px;
    }
    
    #dropBall {
      width: 100%;
      padding: 12px 0;
      background: #2196F3;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 18px;
      cursor: pointer;
      transition: background 0.3s;
      margin-top: 10px;
    }
    
    #dropBall:hover {
      background: #1976D2;
    }
    
    #moneyDisplay {
      font-weight: bold;
    }
    
    canvas {
      display: block;
      margin: 20px auto;
      background: #fafafa;
      border: 2px solid #ddd;
      border-radius: 4px;
    }
    
    #gameOverMessage {
      display: none;
      text-align: center;
      font-size: 26px;
      color: #D32F2F;
      font-weight: bold;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <h1>Advanced Plinko Game</h1>
    <div id="controls">
      <span>Current Money: $<span id="moneyDisplay">10000.00</span></span>
      <div>
        <label for="priceInput">Drop Price: $</label>
        <input type="number" id="priceInput" value="100" min="1">
      </div>
    </div>
    <canvas id="plinkoCanvas" width="500" height="750"></canvas>
    <button id="dropBall">Drop Ball</button>
    <div id="gameOverMessage">Game Over!</div>
  </div>
  
  <script>
    // -------------- Global Money & Game Over Handling --------------
    let currentMoney = 10000;
    let gameOver = false;
    
    function updateMoneyDisplay() {
      document.getElementById('moneyDisplay').innerText = currentMoney.toFixed(2);
    }
    
    function triggerGameOver() {
      gameOver = true;
      document.getElementById('dropBall').disabled = true;
      document.getElementById('gameOverMessage').style.display = 'block';
    }
    
    // -------------- Canvas Setup --------------
    const canvas = document.getElementById('plinkoCanvas');
    const ctx = canvas.getContext('2d');
    
    // -------------- Physics & Game Settings --------------
    const gravity = 0.1;         // Slow downward acceleration.
    const restitution = 0.9;     // Bounce retention.
    const ballRadius = 8;        // Smaller ball.
    
    // Score pad settings.
    const padHeight = 50;
    const padY = canvas.height - padHeight;
    const padCount = 16;
    const padWidth = canvas.width / padCount;
    
    // Score multipliers.
    const leftMultipliers = ["100x", "25x", "10x", "5x", "2.5x", "1.5x", "0.5x", "0.2x"];
    const rightMultipliers = [...leftMultipliers].reverse();
    const scoreMultipliers = leftMultipliers.concat(rightMultipliers);
    
    // ----- Peg Board Settings (Expanded to Fill the Game Screen) -----
    // The peg board will extend from below the spawner near the top to just above the score pads.
    const numPegRows = 15;  
    const yStart = 100;  // Starting y position for the top peg row.
    const pegVSpacing = (padY - yStart) / (numPegRows - 1);  // Even vertical distribution.
    const pegRadius = 4;
    
    // Generate pegs in a triangular arrangement spanning nearly the entire canvas width.
    let pegs = [];
    const margin = 20;  // Margin from left and right edges.
    for (let row = 0; row < numPegRows; row++) {
      const n = row + 1;  // Number of pegs in this row.
      let yPos = yStart + row * pegVSpacing;
      if(n === 1) {
        pegs.push({ x: canvas.width / 2, y: yPos, r: pegRadius });
      } else {
        const spacingRow = (canvas.width - 2 * margin) / (n - 1);
        for (let j = 0; j < n; j++) {
          let xPos = margin + j * spacingRow;
          pegs.push({ x: xPos, y: yPos, r: pegRadius });
        }
      }
    }
    
    // Array for ball objects.
    // Each ball: x, y, vx, vy, r, cost, landed (flag), and collected (flag for winnings)
    let balls = [];
    
    // Array for floating text effects.
    // Each effect: x, y, text, alpha
    let floatingTexts = [];
    
    // -------------- Animation & Physics --------------
    function update() {
      // Update balls.
      for (let ball of balls) {
        if (!ball.landed) {
          // Apply gravity.
          ball.vy += gravity;
          ball.x += ball.vx;
          ball.y += ball.vy;
          
          // Bounce off side walls.
          if (ball.x < ball.r) {
            ball.x = ball.r;
            ball.vx = -ball.vx * restitution;
          }
          if (ball.x > canvas.width - ball.r) {
            ball.x = canvas.width - ball.r;
            ball.vx = -ball.vx * restitution;
          }
          
          // Check collision with pegs.
          for (let peg of pegs) {
            const dx = ball.x - peg.x;
            const dy = ball.y - peg.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < ball.r + peg.r) {
              const nx = dx / dist;
              const ny = dy / dist;
              const dot = ball.vx * nx + ball.vy * ny;
              ball.vx = (ball.vx - 2 * dot * nx) * restitution;
              ball.vy = (ball.vy - 2 * dot * ny) * restitution;
              const overlap = ball.r + peg.r - dist;
              ball.x += nx * overlap;
              ball.y += ny * overlap;
              break;
            }
          }
          
          // Check if the ball touches the score pads.
          if (ball.y + ball.r >= padY) {
            ball.landed = true;
            let padIndex = Math.floor(ball.x / padWidth);
            ball.multiplier = scoreMultipliers[padIndex] || "N/A";
            if (!ball.collected && ball.multiplier !== "N/A") {
              const mVal = parseFloat(ball.multiplier.replace('x', ''));
              const winnings = ball.cost * mVal;
              currentMoney += winnings;
              ball.collected = true;
              updateMoneyDisplay();
              // Create a floating text effect at the ball's location.
              floatingTexts.push({
                x: ball.x,
                y: ball.y,
                text: "+$" + winnings.toFixed(2),
                alpha: 1.0
              });
            }
          }
        }
      }
      // Remove balls that have landed (they disappear).
      balls = balls.filter(ball => !ball.landed);
      
      // Update floating text effects.
      floatingTexts.forEach(effect => {
        effect.y -= 0.5;       // Float upward.
        effect.alpha -= 0.02;  // Fade out.
      });
      floatingTexts = floatingTexts.filter(effect => effect.alpha > 0);
    }
    
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw the spawner triangle at the top.
      ctx.fillStyle = "#888";
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 30);
      ctx.lineTo(canvas.width / 2 - 40, 80);
      ctx.lineTo(canvas.width / 2 + 40, 80);
      ctx.closePath();
      ctx.fill();
      
      // Draw all pegs.
      ctx.fillStyle = "#FF5722";
      for (let peg of pegs) {
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, peg.r, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw score boost pads at the bottom.
      for (let i = 0; i < padCount; i++) {
        const xPos = i * padWidth;
        ctx.fillStyle = "#E0E0E0";
        ctx.fillRect(xPos, padY, padWidth, padHeight);
        ctx.strokeStyle = "#000";
        ctx.strokeRect(xPos, padY, padWidth, padHeight);
        ctx.fillStyle = "#000";
        ctx.font = "bold 12px Arial";
        const text = scoreMultipliers[i];
        const textWidth = ctx.measureText(text).width;
        const textX = xPos + (padWidth - textWidth) / 2;
        const textY = padY + padHeight / 2 + 4;
        ctx.fillText(text, textX, textY);
      }
    }
    
    function drawBalls() {
      for (let ball of balls) {
        ctx.fillStyle = "#2196F3";
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function drawEffects() {
      for (let effect of floatingTexts) {
        ctx.fillStyle = "rgba(0,150,0," + effect.alpha + ")";
        ctx.font = "bold 16px Arial";
        ctx.fillText(effect.text, effect.x, effect.y);
      }
    }
    
    function animate() {
      update();
      drawBoard();
      drawBalls();
      drawEffects();
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    
    // -------------- User Interaction --------------
    document.getElementById('dropBall').addEventListener('click', function() {
      if (gameOver) return;
      
      const priceInput = document.getElementById('priceInput');
      const dropPrice = parseFloat(priceInput.value);
      if (isNaN(dropPrice) || dropPrice <= 0) {
        alert("Invalid drop price.");
        return;
      }
      // If drop price is more than current money, notify without triggering game over.
      if (currentMoney < dropPrice) {
        alert("Not enough money to drop this ball!");
        return;
      }
      
      // Deduct the drop price.
      currentMoney -= dropPrice;
      updateMoneyDisplay();
      
      // Trigger game over only if money goes below 0.
      if (currentMoney < 0) {
        triggerGameOver();
      }
      
      // Spawn a new ball with a random horizontal offset.
      const randomOffset = Math.random() * 40 - 20;  // Offset between -20 and 20.
      const newBall = {
        x: canvas.width / 2 + randomOffset,
        y: 30,
        vx: 0,
        vy: 0,
        r: ballRadius,
        cost: dropPrice,
        landed: false,
        collected: false
      };
      balls.push(newBall);
    });
  </script>
</body>
</html>

