<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Plinko with Money Mechanics</title>
  <style>
    body {
      background: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      text-align: center;
    }
    h1 {
      margin-top: 20px;
      color: #333;
    }
    #controls {
      margin: 10px auto;
    }
    #controls span,
    #controls label {
      font-size: 16px;
      margin: 0 5px;
    }
    #priceInput {
      width: 80px;
      font-size: 16px;
      padding: 2px;
    }
    canvas {
      background: #fff;
      border: 1px solid #ccc;
      display: block;
      margin: 20px auto;
    }
    button {
      font-size: 16px;
      padding: 10px 20px;
      cursor: pointer;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h1>Advanced Plinko (For Fun!)</h1>
  <div id="controls">
    <span>Current Money: $<span id="moneyDisplay">10000.00</span></span>
    &nbsp;&nbsp;&nbsp;
    <label for="priceInput">Drop Price: $</label>
    <input type="number" id="priceInput" value="100" min="1">
  </div>
  <canvas id="plinkoCanvas" width="500" height="750"></canvas>
  <button id="dropBall">Drop Ball</button>

  <script>
    // Get canvas and context
    const canvas = document.getElementById('plinkoCanvas');
    const ctx = canvas.getContext('2d');

    // ----------------- Global Money & Drop Price -----------------
    let currentMoney = 10000;
    function updateMoneyDisplay() {
      document.getElementById('moneyDisplay').innerText = currentMoney.toFixed(2);
    }

    // ------------------ Physics & Game Settings ------------------
    const gravity = 0.1;         // Lower gravity makes the ball fall slowly.
    const restitution = 0.9;     // Bounce energy retention.
    const ballRadius = 10;

    // Score pad settings
    const padHeight = 50;
    const padY = canvas.height - padHeight;
    const padCount = 16;
    const padWidth = canvas.width / padCount;

    // Score multipliers (left half and reversed right half)
    const leftMultipliers = ["100x", "25x", "10x", "5x", "2.5x", "1.5x", "0.5x", "0.2x"];
    const rightMultipliers = [...leftMultipliers].reverse();
    const scoreMultipliers = leftMultipliers.concat(rightMultipliers);

    // Peg settings for a triangular (pyramid) arrangement:
    const numPegRows = 7;
    const pegRadius = 5;
    const pegHSpacing = 40;  // horizontal spacing between pegs
    const pegVSpacing = 50;  // vertical distance between peg rows
    const yStart = 120;      // starting y position for the top peg row

    // Create pegs in a triangular arrangement.
    const pegs = [];
    for (let row = 0; row < numPegRows; row++) {
      const numPegs = row + 1;
      // Center the row horizontally.
      const startX = canvas.width / 2 - ((numPegs - 1) * pegHSpacing) / 2;
      const yPos = yStart + row * pegVSpacing;
      for (let j = 0; j < numPegs; j++) {
        pegs.push({ x: startX + j * pegHSpacing, y: yPos, r: pegRadius });
      }
    }

    // Array to hold all ball objects.
    // Each ball: x, y, vx, vy, r, landed (flag), multiplier (string), cost (drop price), collected (flag)
    const balls = [];

    // ---------------------- Animation & Physics ----------------------
    function update() {
      balls.forEach(ball => {
        if (!ball.landed) {
          // Apply gravity.
          ball.vy += gravity;
          // Update ball position.
          ball.x += ball.vx;
          ball.y += ball.vy;

          // Bounce off side walls.
          if (ball.x < ball.r) {
            ball.x = ball.r;
            ball.vx = -ball.vx * restitution;
          }
          if (ball.x > canvas.width - ball.r) {
            ball.x = canvas.width - ball.r;
            ball.vx = -ball.vx * restitution;
          }

          // Check collision with each peg.
          for (let peg of pegs) {
            const dx = ball.x - peg.x;
            const dy = ball.y - peg.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < ball.r + peg.r) {
              // Calculate collision normal.
              const nx = dx / dist;
              const ny = dy / dist;
              // Reflect velocity.
              const dot = ball.vx * nx + ball.vy * ny;
              ball.vx = (ball.vx - 2 * dot * nx) * restitution;
              ball.vy = (ball.vy - 2 * dot * ny) * restitution;
              // Push the ball out of the peg.
              const overlap = ball.r + peg.r - dist;
              ball.x += nx * overlap;
              ball.y += ny * overlap;
              break;  // Process one collision per frame.
            }
          }

          // When the ball reaches the score pad area.
          if (ball.y + ball.r >= padY) {
            ball.y = padY - ball.r;
            ball.landed = true;
            // Determine pad index based on x-coordinate.
            const padIndex = Math.floor(ball.x / padWidth);
            ball.multiplier = scoreMultipliers[padIndex] || "N/A";
            // If winnings haven't been added yet, process them.
            if (!ball.collected && ball.multiplier !== "N/A") {
              const mVal = parseFloat(ball.multiplier.replace('x', ''));
              const winnings = ball.cost * mVal;
              currentMoney += winnings;
              ball.collected = true;
              updateMoneyDisplay();
            }
          }
        }
      });
    }

    function drawBoard() {
      // Clear the entire canvas.
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw the triangle obstacle at the top.
      ctx.fillStyle = "#888";
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 30);         // Apex (ball starting point)
      ctx.lineTo(canvas.width / 2 - 40, 80);      // Left base corner
      ctx.lineTo(canvas.width / 2 + 40, 80);      // Right base corner
      ctx.closePath();
      ctx.fill();

      // Draw each peg.
      ctx.fillStyle = "#FF5722";
      pegs.forEach(peg => {
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, peg.r, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw score boost pads at the bottom.
      for (let i = 0; i < padCount; i++) {
        const xPos = i * padWidth;
        ctx.fillStyle = "#E0E0E0";
        ctx.fillRect(xPos, padY, padWidth, padHeight);
        ctx.strokeStyle = "#000";
        ctx.strokeRect(xPos, padY, padWidth, padHeight);
        // Draw multiplier text centered on each pad.
        ctx.fillStyle = "#000";
        ctx.font = "bold 12px Arial";
        const text = scoreMultipliers[i];
        const textWidth = ctx.measureText(text).width;
        const textX = xPos + (padWidth - textWidth) / 2;
        const textY = padY + padHeight / 2 + 4;
        ctx.fillText(text, textX, textY);
      }
    }

    function drawBalls() {
      balls.forEach(ball => {
        ctx.fillStyle = "#2196F3";
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();
        // If landed, optionally display the multiplier above the ball.
        if (ball.landed && ball.multiplier) {
          ctx.fillStyle = "#000";
          ctx.font = "bold 14px Arial";
          const txtWidth = ctx.measureText(ball.multiplier).width;
          ctx.fillText(ball.multiplier, ball.x - txtWidth / 2, ball.y - ball.r - 10);
        }
      });
    }

    // Main animation loop.
    function animate() {
      update();
      drawBoard();
      drawBalls();
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // --------------------- User Interaction ---------------------
    document.getElementById('dropBall').addEventListener('click', function() {
      const priceInput = document.getElementById('priceInput');
      const dropPrice = parseFloat(priceInput.value);
      if (isNaN(dropPrice) || dropPrice <= 0) {
        alert("Invalid drop price.");
        return;
      }
      if (currentMoney < dropPrice) {
        alert("Not enough money to drop this ball!");
        return;
      }
      // Deduct the drop price immediately.
      currentMoney -= dropPrice;
      updateMoneyDisplay();
      // Create a new ball starting at the triangle's apex.
      const newBall = {
        x: canvas.width / 2,
        y: 30,
        vx: 0,
        vy: 0,
        r: ballRadius,
        landed: false,
        multiplier: null,
        cost: dropPrice,    // Save this drop's price for when it lands.
        collected: false    // Flag to ensure winnings are added only once.
      };
      balls.push(newBall);
    });
  </script>
</body>
</html>

